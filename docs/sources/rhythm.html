<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
<head>
<link rel="Stylesheet" type="text/css" href="../cludg.css"/>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
<title>
rhythm</title>
</head>
<body>
<div id="navbar">
<table cellspacing="0" cellpadding="0" border="0" style="width: 100%;">
<colgroup span="3">
<col width="0*"/>
<col width="0*"/>
<col width="1*"/>
</colgroup>
<tr>
<td align="left" valign="baseline">
<a href="score.html">
Prev:&nbsp;score</a>
<br/>
<a href="pitch.html">
Next:&nbsp;pitch</a>
</td>
<td>
&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td align="left" valign="baseline">
<span class="upchain">
<b>
rhythm</b>
<br/>
<a href="../index.html">
Index</a>
</span>
&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div class="cludg-doc-body">
<h2>
rhythm
</h2>
<table style="width: 100%;" class="summary-table">
<tr class="table-heading-color">
<th class="summary" colspan="2">
Function summary</th>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233983">
accented-yati-phrase</a>
</td>
<td class="summary">
gati pala-lengths gap <em>&amp;rest</em> args <em>&amp;key</em> (type '(:srotovahayati :at-end)) <em>&amp;allow-other-keys</em></td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233987">
bpm-&gt;duration</a>
</td>
<td class="summary">
beats tempo</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233965">
count-shortest</a>
</td>
<td class="summary">
sequence</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233977">
cut-holes</a>
</td>
<td class="summary">
sequence binary-list <em>&amp;key</em> (swallow nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233966">
divide-shortest</a>
</td>
<td class="summary">
sequence <em>&amp;key</em> (divide 2) (count nil) (section nil) (seed nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233981">
durational-accent</a>
</td>
<td class="summary">
lengths <em>&amp;key</em> (divide 2) (divide-n 1) (divide-prob 0.5) (tie-n 0) (tie-prob 0.5) (tie-previous-beat? nil) (grace-n 0) (grace-length 1/8) (grace-prob 0.5) (merge-n 2) (merge-prob 0.5) (whole-note-prob 0.1) (set nil) (ignore nil) (seed nil) (format :omn)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233963">
even-length-rhythm</a>
</td>
<td class="summary">
total-duration pattern <em>&amp;key</em> prefix suffix (time-sig '(4 4))</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233982">
gen-matras</a>
</td>
<td class="summary">
gati jathi jathi-number <em>&amp;key</em> prefix suffix</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233992">
insert-into-bar</a>
</td>
<td class="summary">
positions new lengths <em>&amp;key</em> section seed</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233988">
isolate-time-signatures</a>
</td>
<td class="summary">
ts-forms</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233989">
length-&gt;time-signature</a>
</td>
<td class="summary">
sequence</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233970">
length-divide-ext</a>
</td>
<td class="summary">
count divide length <em>&amp;rest</em> args <em>&amp;key</em> seed</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233985">
lengths-with-merged-ties</a>
</td>
<td class="summary">
sequence</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233969">
map-tuplet</a>
</td>
<td class="summary">
fn lengths <em>&amp;rest</em> arglist</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233975">
merge-rest-into-note</a>
</td>
<td class="summary">
sequence <em>&amp;key</em> (flat nil) (section nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233990">
metric-shift</a>
</td>
<td class="summary">
l lengths</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233971">
note-rest-series</a>
</td>
<td class="summary">
positions sequence <em>&amp;key</em> (flat nil) (swallow nil) (section nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233973">
position-to-rest</a>
</td>
<td class="summary">
position sequence <em>&amp;key</em> (n 1) (flat nil) (swallow t) (section nil) (seed nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233991">
shift-meter-boundaries</a>
</td>
<td class="summary">
lengths positions</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233964">
tie-whole-notes</a>
</td>
<td class="summary">
lengths tie-prob <em>&amp;key</em> (seed nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233986">
total-duration</a>
</td>
<td class="summary">
sequence <em>&amp;optional</em> float?</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233961">
tuplet-rhythm</a>
</td>
<td class="summary">
lengths subdivisions <em>&amp;rest</em> args <em>&amp;key</em> (length-dividend 1/2) (count-offset 0) (position 'e) (type '?) seed <em>&amp;allow-other-keys</em></td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233962">
tuplet-walk-rhythm</a>
</td>
<td class="summary">
bar-no <em>&amp;key</em> (bar-length 1/2) (subdivisions-ambitus '(2 7)) (rest-distances '(7 8 9)) (rest-distance-order :rnd) (last-bar nil) (seed nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233976">
_cut-holes</a>
</td>
<td class="summary">
lengths binary-list</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233978">
_durational-accent-divide</a>
</td>
<td class="summary">
lengths <em>&amp;key</em> (divide 2) (n 1) (divide-prob 0.5) (tie-n 0) (tie-prob 0.5) (tie-previous-beat? nil) (grace-n 0) (grace-length 1/8) (grace-prob 0.5) (set nil) (ignore nil) (seed nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233979">
_durational-accent-merge</a>
</td>
<td class="summary">
lengths <em>&amp;key</em> (n 2) (prob 0.5) (seed nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233980">
_durational-accent-whole-note</a>
</td>
<td class="summary">
lengths <em>&amp;key</em> (whole-note-prob 0.1) (seed nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233968">
_map-tuplet-internal</a>
</td>
<td class="summary">
fn lengths more-args <em>&amp;key</em> (type :extend)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233974">
_merge-rest-into-note</a>
</td>
<td class="summary">
lengths</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233967">
_partition-args</a>
</td>
<td class="summary">
keywords arglist</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233972">
_position-to-rest</a>
</td>
<td class="summary">
position lengths <em>&amp;key</em> (n 1) (seed nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="rhythm.html#_g233984">
_remove-rest-articulations</a>
</td>
<td class="summary">
sequence</td>
</tr>
</table>
<div class="defun">
<div class="defunsignatures">
<a id="_g233961">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
tuplet-rhythm&nbsp;&nbsp;</td>
<td class="lambda-list">
lengths subdivisions <em>&amp;rest</em> args <em>&amp;key</em> (length-dividend 1/2) (count-offset 0) (position 'e) (type '?) seed <em>&amp;allow-other-keys</em></td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Subdivides given note `lengths'. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
lengths: list of length values, can be nested. 
 </p>
</li>
<li>
<p>
subdivisions: (circling list of ints) specifies tuplet sequence. 
 </p>
</li>
<li>
<p>
length-dividend (default 1/2): duration ratio divided by subdivisions. Default case are half note subdivisions, ie. a subdivision of 3 results 3h notes (triplets splitting a half note). 
 </p>
</li>
<li>
<p>
count-offset (default -1): `subdivisions' also specifies number of equally spaced notes per tuplet plus amount of `count-offset' . I.e., if `count-offset' = 0 then each note is split into subdivision notes. 
 
 All keyword args from `length-divide2' are inherited, but some with different default. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<pre>
    (tuplet-rhythm '(1/2 1/2 1/2) '(3 4 5)) 
     =&gt; (1/6 1/6 1/6 1/8 1/8 1/8 1/8 1/10 1/10 1/10 1/10 1/10) </pre>
<p>
</p>
<pre>
    (tuplet-rhythm (gen-repeat 8 '((1/2))) '(3 4 5 6 5 4 3 2)) </pre>
<p>
With irregular meter 
 </p>
<pre>
    (tuplet-rhythm (gen-eval 4 '(gen-repeat (rnd1 :low 2 :high 5) 'h)) '(3 4 5 6 5 4 3 2) :seed 1234) </pre>
<p>
</p>
<h4>
BUGS: </h4>
<p>
Seed argument not working as expected -- it is not even used in this function! 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233962">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
tuplet-walk-rhythm&nbsp;&nbsp;</td>
<td class="lambda-list">
bar-no <em>&amp;key</em> (bar-length 1/2) (subdivisions-ambitus '(2 7)) (rest-distances '(7 8 9)) (rest-distance-order :rnd) (last-bar nil) (seed nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Some custom algorithm to create rhythmic phrases that randomly walk across tuplet subdivisions and includes some rests. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
bar-no (int): number of bars to generate 
 </p>
</li>
<li>
<p>
bar-length: regular duration of resulting bars 
 </p>
</li>
<li>
<p>
subdivisions-ambitus: range of tuplet subdivisions 
 </p>
</li>
<li>
<p>
rest-distances: distances between rests 
 </p>
</li>
<li>
<p>
rest-distance-order (:rnd or :seq): whether rest distances will be in the given order (:seq) or randomised (:rnd) 
 </p>
</li>
<li>
<p>
last-bar (flat or nested OMN expression, but typically only a rhythm): one or more bars added at end after bar-no bars. If nil, no bar is added. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<pre>
    (tuplet-walk-rhythm 7 :seed 569 :rest-distances '(9 1 13) :last-bar '(1/4 -1/4)) </pre>
<p>

 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233963">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
even-length-rhythm&nbsp;&nbsp;</td>
<td class="lambda-list">
total-duration pattern <em>&amp;key</em> prefix suffix (time-sig '(4 4))</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Custom algorithm to create rhythmic phrases consisting of even note durations over a certain time. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
total-duration (length value): duration of the generated phrase including the prefix and suffix length. 
 </p>
</li>
<li>
<p>
pattern (length value, list of length values, or OMN sequence): rhythmic value(s) to repeat 
 </p>
</li>
<li>
<p>
prefix (length value, list of length values, or OMN sequence): preceeding phrase 
 </p>
</li>
<li>
<p>
suffix (length value, list of length values, or OMN sequence): succeeding phrase 
 </p>
</li>
<li>
<p>
time-sig: time signature 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<pre>
    (even-length-rhythm 'w_w '5q :prefix '-w_5h :suffix '-5q_5h_q) </pre>
<p>
Lists and OMN sequences can be specified for pattern, prefix and suffix 
 </p>
<pre>
    (even-length-rhythm 'w_w_w '(3q c4 stacc 3e) :prefix '-3h :suffix '(q b3d4 -q)) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233964">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
tie-whole-notes&nbsp;&nbsp;</td>
<td class="lambda-list">
lengths tie-prob <em>&amp;key</em> (seed nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Every bar with only a single note in it is potentially tied over to the next bar, and that way can increase the degree of rhythmic contrast in a rhythmic sequence. 
 </p>
<p>
NOTE: this function is intended for processing note length values only, as ties are otherwise also affected by pitches. If given a full OMN sequence, then nevertheless only the transformed rhythm is returned. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
sequence (nested OMN length sequence): input rhythm to process. 
 </p>
</li>
<li>
<p>
tie-prob (number or list of numbers): Probability whether 'whole' notes (notes filling a whole sublist) are tied or not. If 1, all whole notes are tied; if 0, no note is tied; any number in between sets the probability. If a list of numbers, it sets the probability of individual whole notes in order to be tied over. For example, `tie-prob' can be a list of binary numbers generated with Openmodus' binary number functions. 
 </p>
</li>
<li>
<p>
seed (integer): random seed for probability. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<p>
Enforce tie at end of every bar with only a single note by setting the probability to 1 (except the last -- there is never a tied added at the end of the last bar). 
 </p>
<pre>
    (tie-whole-notes '((h) (q q) (h) (h)) 1) </pre>
<p>
Whether or not a tie is added is randomised and should be rather evenly distributed (probability is 0.7). 
 </p>
<pre>
    (tie-whole-notes '((h) (q q) (h) (h)) 0.7) </pre>
<p>
The tie probability is controlled for individual 'whole' notes in the sequence. Note that the probabilities are only given for the actual 'whole' notes, not intermediate bars. 
 </p>
<pre>
    (tie-whole-notes '((h) (q q) (h) (h)) '(0 1)) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233965">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
count-shortest&nbsp;&nbsp;</td>
<td class="lambda-list">
sequence</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Count the number of the shortest notes in sequence. Helper function for using `divide-shortest'. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233966">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
divide-shortest&nbsp;&nbsp;</td>
<td class="lambda-list">
sequence <em>&amp;key</em> (divide 2) (count nil) (section nil) (seed nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Increase rhythmic contrast by dividing the shortest notes in the given `sequence'. 
 </p>
<p>
</p>
<h4>
Examples: </h4>
<pre>
    (divide-shortest '(1/8 1/16 1/16)) </pre>
<p>
</p>
<pre>
    (divide-shortest '(1/8 1/16 1/16) :count 1) </pre>
<p>
Note that if sequence is a full OMN expression, then the added notes cause all other parameters to shift forward. Additional parameters are added at the end by circling. 
 </p>
<pre>
    (divide-shortest '((e c4 s d4 e4) (e f4 s e4 d4) (q g4))) 
     =&gt; ((E C4 T D4 E4 F4 E4) (E D4 T G4 C4 D4 E4) (Q F4)) </pre>
<p>
</p>
<pre>
    (divide-shortest '((e c4 s d4 e4) (e f4 s e4 d4) (q g4)) :section '(1)) </pre>
<p>

 This function is a simplified variant of `length-divide'. For more control use that function instead. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233967">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
_partition-args&nbsp;&nbsp;</td>
<td class="lambda-list">
keywords arglist</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
[Aux for map-tuplet] Partition the argument list around the first argument that is in KEYWORDS. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233968">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
_map-tuplet-internal&nbsp;&nbsp;</td>
<td class="lambda-list">
fn lengths more-args <em>&amp;key</em> (type :extend)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
[Aux for map-tuplet] Defines actual function. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233969">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
map-tuplet&nbsp;&nbsp;</td>
<td class="lambda-list">
fn lengths <em>&amp;rest</em> arglist</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
A function for varying tuplet groups one by one: map-tuplet applies fn to each tuplet length group in lengths. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
fn: a function expecting a length list, and potentially more arguments if further args are given 
 </p>
</li>
<li>
<p>
lengths: a (possibly nested) lengths list 
 </p>
</li>
<li>
<p>
arglist: further argument 
 </p>
<ul>
<li>
<p>
args -- arguments that are part of arg-list before keyword args: more argument lists to map in parallel. 
 </p>
</li>
<li>
<p>
type -- a keyword arg that is part of arglist. <span class="keyword">
:extend, </span>
<span class="keyword">
:denominator </span>
or <span class="keyword">
:tuplet. </span>
The default is <span class="keyword">
:extend </span>
(inherited from split-lengths). 
 </p>
</li>
</ul>
</li>
</ul>
<p>
</p>
<h4>
Examples: </h4>
<p>
</p>
<pre>
    (setf rhy '((-1/6 1/6 1/6 -1/8 1/8 1/8 1/8) (-1/10 1/10 1/10 1/10 1/10 -1/12 1/12 1/12 1/12 1/12 1/12) (-1/10 1/10 1/10 1/10 1/10 -1/8 1/8 1/8 1/8) (-1/6 1/6 1/6 -1/4 1/4))) </pre>
<p>
In this first example, all tuplet groups in rhy are rotated by one. 
 </p>
<p>
</p>
<pre>
    (map-tuplet #'(lambda (ls) (gen-rotate 1 ls)) rhy) </pre>
<p>
Additional arguments can be given to fn by specifying further argument lists to map-tuplet. If an argument list is shorter than the number of tuplet groups in lengths then it is circled through. In this example, tuplet groups are rotated by 1 or 2 alternating. 
 </p>
<p>
</p>
<pre>
    (map-tuplet #'(lambda (ls n) (gen-rotate n ls)) 
                 rhy 
                 '(1 2)) </pre>
<p>
</p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233970">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
length-divide-ext&nbsp;&nbsp;</td>
<td class="lambda-list">
count divide length <em>&amp;rest</em> args <em>&amp;key</em> seed</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Same as length-divide, but arg divide is list of ints (elements circled through). 
 </p>
<p>
Note: implemented by calling length-divide internally for each sublist in length, and therefore arguments like section and exclude are not supported. 
 </p>
<p>
</p>
<h4>
Examples: </h4>
<pre>
    (length-divide-ext 1 '(2 3) '((q q) (q q)) :seed 1) 
     =&gt; ((1/8 1/8 1/4) (1/4 1/12 1/12 1/12)) </pre>
<p>
</p>
<pre>
    (length-divide-ext 1 '(2 3) '(q q) :seed 1) 
     =&gt; ((1/8 1/8) (1/12 1/12 1/12)) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233971">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
note-rest-series&nbsp;&nbsp;</td>
<td class="lambda-list">
positions sequence <em>&amp;key</em> (flat nil) (swallow nil) (section nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Turn notes at specific positions (actually, distances between positions) into rests. This function is like the Opusmodus built-in length-rest-series, but supports arbitrary OMN expressions as input and additionally the arguments swallow and section. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
positions (list of ints): 1-based positions of notes to be turned into rests 
 </p>
</li>
<li>
<p>
sequence (list of lengths or OMN expression): music to process 
 </p>
</li>
<li>
<p>
flat (Boolean): whether positions count for sublists (nil) or the whole list (T) 
 </p>
</li>
<li>
<p>
swallow (Boolean): whether the pitches of notes turned into rests should be shifted to the next note or omitted (swallowed) 
 </p>
</li>
<li>
<p>
section (list of ints): 0-based positions of sublists to process. This argument is ignored if flat is T. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<p>
</p>
<pre>
    (setf melody '((s eb6 &lt; leg f5 &lt; leg c5 &lt; leg f5 &lt; leg) (e e6 f - -q))) 
     (note-rest-series '(1 1) melody :swallow T :section '(0)) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233972">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
_position-to-rest&nbsp;&nbsp;</td>
<td class="lambda-list">
position lengths <em>&amp;key</em> (n 1) (seed nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
[Aux] Processing plain list of lengths. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233973">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
position-to-rest&nbsp;&nbsp;</td>
<td class="lambda-list">
position sequence <em>&amp;key</em> (n 1) (flat nil) (swallow t) (section nil) (seed nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Turn notes at the given position in the bar into rests. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
position (symbol or integer): position of the note to turn into a rest. If a positive integer, it denotes the 0-based position. If a negative integer, it counts backwards from the end (-1 is the last element, -2 the one before the last and so on). Symbols have the following meaning: s - first note (start); e - last note (end); ? - randomly chosen position. 
 </p>
</li>
<li>
<p>
sequence (list of lengths or OMN expression): music to process. 
 </p>
</li>
<li>
<p>
n (integer): how many consecutive notes after `position' to affect. 
 </p>
</li>
<li>
<p>
flat (Boolean): whether positions count for sublists (nil) or the whole list (T) 
 </p>
</li>
<li>
<p>
swallow (Boolean): whether the pitches of notes turned into rests should be shifted to the next note or omitted (swallowed) 
 </p>
</li>
<li>
<p>
section (list of ints): 0-based positions of sublists to process. This argument is ignored if flat is T. 
 </p>
</li>
<li>
<p>
seed (integer): random seed for ? position. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<p>
Processing a flat list of durations. 
 </p>
<pre>
    (position-to-rest 's '(q q q q) :n 2) </pre>
<p>
A sequence to be processed in following examples. 
 </p>
<pre>
    (setf seq '((q c4 q d4 q e4 q d4) (h b3 q g4 q f4) (w e4))) </pre>
<p>
Create rests at the beginning of every bar. 
 </p>
<pre>
    (position-to-rest 's seq) </pre>
<p>
Create rests at the end of every bar using a negative position 
 </p>
<pre>
    (position-to-rest -1 seq) </pre>
<p>

 Create rests at a random position in the first bar (section) with two consecutive rests. 
 </p>
<pre>
    (position-to-rest '? seq :section '(0) :n 2) </pre>
<p>
Create a rest at a random position in every bar. 
 </p>
<pre>
    (position-to-rest '? seq :seed 1) </pre>
<p>
Process the flattened sequence and create two consecutive rests starting from position 5, which happens to be in the second bar. 
 </p>
<pre>
    (position-to-rest 5 seq :n 2 :flat T) </pre>
<p>
If there already is a rest at the given position, then it is simply kept as such. 
 </p>
<pre>
    (position-to-rest 1 '(q -q q q) :n 2) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233974">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
_merge-rest-into-note&nbsp;&nbsp;</td>
<td class="lambda-list">
lengths</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
[Aux def] 
 All rests are merged into the following note. This function can be useful for producing harmonic rhythms. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
lengths: a flat list of length values 
 </p>
</li>
</ul>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233975">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
merge-rest-into-note&nbsp;&nbsp;</td>
<td class="lambda-list">
sequence <em>&amp;key</em> (flat nil) (section nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
All rests are merged into the following note. This function can be useful for producing harmonic rhythms. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
sequence: OMN sequence, can be nested 
 </p>
</li>
<li>
<p>
flat (Boolean): whether or not to merge rests across bar boundaries 
 </p>
</li>
<li>
<p>
section (list of positive integers): selection of sublists to process 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<p>
</p>
<pre>
    (merge-rest-into-note '((-h w. e4 pp) (-h w. gs4 pp) (-h w. gs4 pp))) 
     =&gt; ((d e4 pp) (d gs4) (d gs4)) </pre>
<p>
</p>
<pre>
    (merge-rest-into-note '((-w) (-h h e4 pp)) :flat T) 
     =&gt; ((w e4 pp tie) (w e4 pp)) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233976">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
_cut-holes&nbsp;&nbsp;</td>
<td class="lambda-list">
lengths binary-list</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
[Aux] Expects a list of lengths and a matching binary list. Every length at a position of a 1 in the binary list is left untouched, while every length at a 0 is turned into a rest. 
 </p>
<p>
If binary-list is shorter than lengths it is repeated in a circular fashion. 
 </p>
<p>
Related: length-rest-series 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233977">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
cut-holes&nbsp;&nbsp;</td>
<td class="lambda-list">
sequence binary-list <em>&amp;key</em> (swallow nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Turns notes in `sequence' into rests if `binary-list' contains a 0 at the matching position. Notes are left untouched if there is a 1 at the matching position. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
sequence (list of lengths or OMN expression): music to process 
 </p>
</li>
<li>
<p>
binary-list (flat list of ints): 
 </p>
</li>
<li>
<p>
flat (Boolean): whether binary-list count for sublists (nil) or the whole list (T) 
 </p>
</li>
<li>
<p>
swallow (Boolean): whether the pitches of notes turned into rests should be shifted to the next note or omitted (swallowed) 
 </p>
</li>
</ul>
<h4>
See Also: </h4>
<p>
<a href="rhythm.html#_g233971">
note-rest-series</a>

 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233978">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
_durational-accent-divide&nbsp;&nbsp;</td>
<td class="lambda-list">
lengths <em>&amp;key</em> (divide 2) (n 1) (divide-prob 0.5) (tie-n 0) (tie-prob 0.5) (tie-previous-beat? nil) (grace-n 0) (grace-length 1/8) (grace-prob 0.5) (set nil) (ignore nil) (seed nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Adds durational accents on first notes of bars by subdividing the last note of the preceding bar. `lengths' must be a list of length lists (multiple bars). 
 </p>
<p>
If a bar starts with a rest, then it cannot carry a durational accent, and hence its preceding note is never subdivided. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
divide (integer or list of integers, default 2): specifies into how many equal note values notes preceeding a durational accent are subdivided. If list of integer, subdivision is randomly chosen. 
 </p>
</li>
<li>
<p>
n (integer): maximum number of notes at end of bars that are potentially subdivided. 
 </p>
</li>
<li>
<p>
divide-prob (default 0.5): probability value between 0.0 and 1.0, controlling whether a note that could be subdivided for creating a durational accent actually will be. Higher values make durational accents more likely. 
 </p>
</li>
<li>
<p>
tie-n (integer): maximum number of subdivided notes at end of bars (before the next durational accent) that are potentially tied together. Should not be larger than n*divide. 
 </p>
</li>
<li>
<p>
tie-previous-beat? (Bool): whether or not the first subdivided note before the durational accent is tied to the preceeding note (e.g., the preceeding accent). Such tie never occurs across bar lines. 
 </p>
</li>
<li>
<p>
tie-prob: probability value controlling whether subdivided notes are tied. 
 </p>
</li>
<li>
<p>
grace-n (integer): number of grace notes potentially inserted before first notes of bars. 
 </p>
</li>
<li>
<p>
grace-length (length value, default 1/8): notated note value of inserted grace notes. 
 </p>
</li>
<li>
<p>
grace-prob (default 0.5): probability value controlling whether grace notes are inserted. 
 </p>
</li>
<li>
<p>
set (length or list of lengths): only specified lengths are subdivided. 
 </p>
</li>
<li>
<p>
ignore (length or list of lengths): specified lengths are *not* subdivided. 
 </p>
</li>
<li>
<p>
seed (integer): random seed. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<pre>
    (_durational-accent-divide (gen-repeat 2 '((h q) (q q q) (h -q))) :divide '(2 3) :n 2 :seed 4321) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233979">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
_durational-accent-merge&nbsp;&nbsp;</td>
<td class="lambda-list">
lengths <em>&amp;key</em> (n 2) (prob 0.5) (seed nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Adds durational accents on first notes of bars by merging notes at the beginning of a bar. `lengths' must be a list of length lists (multiple bars). 
 </p>
<p>
If a bar starts with a rest, then it cannot carry a durational accent, and hence notes are not merged. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
n (integer): number of notes at beginning of bars that are potentially subdivided. 
 </p>
</li>
<li>
<p>
prob (default 0.5): probability value between 0.0 and 1.0, controlling whether notes that could be merged for creating a durational accent actually will be. Higher values make durational accents more likely. 
 </p>
</li>
<li>
<p>
seed (integer): random seed. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<pre>
    (_durational-accent-merge (gen-repeat 4 '((q q q))) :n 3 :seed 3333) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233980">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
_durational-accent-whole-note&nbsp;&nbsp;</td>
<td class="lambda-list">
lengths <em>&amp;key</em> (whole-note-prob 0.1) (seed nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Adds quasi durational accents on first notes of bars (and simplifies the resulting music) by merging all notes of some bars into a single note taken the whole duration of that bar. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233981">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
durational-accent&nbsp;&nbsp;</td>
<td class="lambda-list">
lengths <em>&amp;key</em> (divide 2) (divide-n 1) (divide-prob 0.5) (tie-n 0) (tie-prob 0.5) (tie-previous-beat? nil) (grace-n 0) (grace-length 1/8) (grace-prob 0.5) (merge-n 2) (merge-prob 0.5) (whole-note-prob 0.1) (set nil) (ignore nil) (seed nil) (format :omn)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Adds durational accents on first notes of bars by subdividing the last note of the preceding bar (see divide-related args) or merging notes at the beginning of a bar (see merge-related args). Subdivided notes can be partially tied together for rhythmic variety (see tie-related args), and durational accents can also be expressed with grace notes (see grace-related args). 
 </p>
<p>
While `durational-accent' only supports accents of the first beat of each bar, you can easily realise other accent patterns by temporarily rebarring the music (e.g., with `omn-to-time-signature' and perhaps `length-&gt;time-signature'), and then afterwards align the result of `durational-accent' again with the original time signatures (e.g., with `copy-time-signature'). 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
lengths: a list of length lists (multiple bars). `length' can also be arbitrary OMN expressions, but only length lists are returned and other parameters are ignored. 
 </p>
</li>
<li>
<p>
divide (integer or list of integers, default 2): specifies into how many equal note values notes preceeding a durational accent are subdivided. If list of integer, subdivision is randomly chosen. 
 </p>
</li>
<li>
<p>
divide-n (integer): number of notes at end of bars that are potentially subdivided. If a bar starts with a rest, then it cannot carry a durational accent, and hence its preceding note is never subdivided. 
 </p>
</li>
<li>
<p>
divide-prob (default 0.5): probability value between 0.0 and 1.0, controlling whether a note that could be subdivided for creating a durational accent actually will be. Higher values make durational accents more likely. 
 </p>
</li>
<li>
<p>
tie-n (integer): maximum number of subdivided notes at end of bars (before the next durational accent) that are potentially tied together. Should not be larger than divide * divide-n. (The returned notes are not necessarily tied but can instead be notated, e.g., as dotted note values.) 
 </p>
</li>
<li>
<p>
tie-previous-beat? (Bool): whether or not the first subdivided note before the durational accent is tied to the preceeding note (e.g., the preceeding accent). Such tie never occurs across bar lines. 
 </p>
<ul>
<li>
<p>
NOTE: If tie-previous-beat? is T, then you may want the argument divide to be 3 or larger, and tie-n to be only 1 (or slightly larger for large values of divide), because otherwise you also turn the preceeding note into a durational accent. 
 </p>
</li>
</ul>
</li>
<li>
<p>
tie-prob: probability value controlling whether subdivided notes are tied. 
 </p>
</li>
<li>
<p>
merge-n (integer): number of notes at beginning of bars that are potentially subdivided. 
 </p>
</li>
<li>
<p>
merge-prob (default 0.5): probability value controlling whether notes at the beginning of a bar are merged. 
 </p>
</li>
<li>
<p>
whole-note-prob: probability value controlling whether all notes of a bar are merged to form quasi a whole note spanning that whole bar. 
 </p>
</li>
<li>
<p>
grace-n (integer): number of grace notes potentially inserted before first notes of bars. 
 </p>
</li>
<li>
<p>
grace-length (length value, default 1/8): note value of inserted grace notes. 
 </p>
</li>
<li>
<p>
grace-prob (default 0.5): probability value controlling whether grace notes are inserted. 
 </p>
</li>
<li>
<p>
set (length or list of lengths): only specified lengths are subdivided. 
 </p>
</li>
<li>
<p>
ignore (length or list of lengths): specified lengths are *not* subdivided. 
 </p>
</li>
<li>
<p>
format (either <span class="keyword">
:omn </span>
or :length): set the output format. In <span class="keyword">
:length </span>
format, grace notes are represented explicitly as acciaccatura and ties are represented explicitly, in length format they have simply the duration 0. 
 </p>
</li>
<li>
<p>
seed (integer): random seed. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<p>
Evaluate these examples multiple times to see range of solutions. 
 </p>
<pre>
    (durational-accent (gen-repeat 4 '((q q q))) :divide 2 :divide-n 2 :merge-n 3) 
     (durational-accent (gen-repeat 4 '((q q q))) :divide '(2 3) :divide-n 2 :merge-n 3) </pre>
<p>
allow for ties for greater rhythmic variety, in particular for higher <span class="keyword">
:divide </span>
values 
 </p>
<pre>
    (durational-accent (gen-repeat 4 (list (gen-repeat 4 '(1/4)))) 
                      :divide '(3 4) :divide-n 2 
                      :tie-n 2 :tie-prob 0.8) </pre>
<p>
ties with ties to previous beat 
 </p>
<pre>
    (durational-accent (gen-repeat 4 (list (gen-repeat 2 '(1/4)))) 
                      :divide '(4) :divide-n 2 :divide-prob 1 
                      :tie-n 1 :tie-prob 1 :tie-previous-beat? t) </pre>
<p>

 shorter tuplet groups to create accents 
 </p>
<pre>
    (durational-accent (gen-repeat 4 '((q q q))) :divide '(5 6 7) :divide-n 1 :divide-prob 0.7 :merge-n 3) </pre>
<p>
inserting grace notes, but without subdividing notes at end of bar 
 </p>
<pre>
    (durational-accent (gen-repeat 4 '((q q q))) :divide-n 0 :merge-n 3 :grace-n 2) </pre>
<p>
metric structure can be irregular, but accents are still created on first beat 
 </p>
<pre>
    (durational-accent  
      (gen-eval 4 '(gen-repeat (rnd1 :low 2 :high 5) (rnd-pick '(h q)))) 
      :divide '(2 3) :divide-n 3 :merge-n 3) </pre>
<p>
Note that you can create potential accents on each bear, on syncopations or other accent patterns beyond emphasising the first note of bars by using this function with sublists (temporary bars) according to where you want to have your accents, and then in a next step re-barring your results, e.g., with the function omn-to-time-signature. 
 </p>
<p>
If you want your final rhythm to contain rests you best add these to your rhythmic material before processing it with this function, because turning notes into rests afterwards can contradict your durational accents. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233982">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
gen-matras&nbsp;&nbsp;</td>
<td class="lambda-list">
gati jathi jathi-number <em>&amp;key</em> prefix suffix</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Generates a sequence of matras (equal note durations) where `gati' defines the beat subdivision, `jathi' the number of matras per 'bar' (sublist) and `jathi-number' the resulting number of sublists. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
gati (int) 
 </p>
</li>
<li>
<p>
jathi (int) 
 </p>
</li>
<li>
<p>
yat-number (int) 
 </p>
</li>
<li>
<p>
prefix (length value or length sequence, possibly nested): preceeding phrase 
 </p>
</li>
<li>
<p>
suffix (length value or length sequence, possibly nested): succeeding phrase 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<p>
gati 5 (quintuplets), jathi 4 
 </p>
<pre>
    (gen-matras 5 4 3) </pre>
<p>
gati 5 (quintuplets), jathi 4, but preceeded by a quarter note rest. 
 </p>
<pre>
    (gen-matras 5 4 3 :prefix '-q) </pre>
<p>
</p>
<h4>
Notes: </h4>
<p>
See Reina (2016) for details on the terms matras, gati and jathi. 
 
 </p>
<ul>
<li>
<p>
Reina, R. (2016) Applying Karnatic Rhythmical Techniques to Western Music. Routledge. 
 </p>
</li>
</ul>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233983">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
accented-yati-phrase&nbsp;&nbsp;</td>
<td class="lambda-list">
gati pala-lengths gap <em>&amp;rest</em> args <em>&amp;key</em> (type '(:srotovahayati :at-end)) <em>&amp;allow-other-keys</em></td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Generates the matras sequence for a yati phrase, see Reina (2016, p. 205ff) for details. Resulting sublists are jathis for potential post-processing (e.g., adding an accent on their first notes) before redefining the metric structure (usually to follow the tala, e.g., with `omn-to-time-signature'). 
 </p>
<p>
NOTE: In contrast to Karnatic music, resulting accents are expressed by durational accents by this function. Hence the word `accented' in the function name. 
 
 </p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
gati (OMN length): beat subdivision 
 </p>
</li>
<li>
<p>
pala-lengths (list of ints): number of matras per pala 
 </p>
</li>
<li>
<p>
gap (OMN length, typically a rest): length of gaps between palas (always constant). For mridangamyati phrases, when you need different gap lengths, simply append two calls to the present function. 
 </p>
</li>
<li>
<p>
type (list of two keywords): specifies first the type of the yati phrase (:srotovahayati, where matras are added or <span class="keyword">
:gopuchayati, </span>
where matras are removed over time). Secondly, it sets at which side the pala matras are added or removed (:at-end <span class="keyword">
:at-front). </span>
There are four combinations in total. You can compose mridangamyati and damaruyati yati phrases by combining the results of two calls of this function. Note that inserting matras in the middle is currently not supported. 
 </p>
</li>
</ul>
<p>
Additionally, all `durational-accent' key args are supported. 
 </p>
<p>
</p>
<h4>
Examples: </h4>
<pre>
    (accented-yati-phrase 's '(4 7 10 13) '-e :type '(:srotovahayati :at-end) :divide-prob 0.3 :merge-prob 0.7 :seed 1) </pre>
<p>
</p>
<pre>
    (accented-yati-phrase '3q '(4 7 10 13) '-3e :type '(:gopuchayati :at-front) :divide-prob 0.7 :merge-prob 0.5 :seed 3) </pre>
<p>
</p>
<h4>
Notes: </h4>
<p>
</p>
<ul>
<li>
<p>
Reina, R. (2016) Applying Karnatic Rhythmical Techniques to Western Music. Routledge. 
 
 </p>
</li>
</ul>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233984">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
_remove-rest-articulations&nbsp;&nbsp;</td>
<td class="lambda-list">
sequence</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Strips all articulations from rests. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
sequence: OMN expression that _cannot_ be nested. 
 
 TMP function -- only necessary until length-rest-merge or omn-merge-rests support merging rests with articulations. 
 </p>
</li>
</ul>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233985">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
lengths-with-merged-ties&nbsp;&nbsp;</td>
<td class="lambda-list">
sequence</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Returns a flat list of lengths that preserves the lengths in `sequence' including their tied notes. 
 
 </p>
<h4>
Examples: </h4>
<pre>
    (lengths-with-merged-ties '((h c4 pizz q arco+tie) (q h tie) (h.))) 
     =&gt; (1/2 1/2 5/4) </pre>
<p>
Contrast: 
 </p>
<pre>
    (omn :length '((h c4 pizz q arco+tie) (q h tie) (h.))) 
     =&gt; ((1/2 1/4) (1/4 1/2) (3/4)) </pre>
<p>
</p>
<h4>
See Also: </h4>
<p>
</p>
<pre>
    (omn-merge-ties (flatten-omn '((h c4 pizz q arco+tie) (q h tie) (h.)))) 
     =&gt; (h c4 pizz c4 arco wq) </pre>
<p>

 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233986">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
total-duration&nbsp;&nbsp;</td>
<td class="lambda-list">
sequence <em>&amp;optional</em> float?</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Returns the total duration (length) of `sequence', i.e. the sum of the length of all its notes and rests. 
 </p>
<p>
If `float?' is true the result is a float. 
 </p>
<p>
</p>
<h4>
Examples: </h4>
<pre>
    (total-duration '((h c4 q) (q h tie) (h.))) 
     =&gt; 9/4 </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233987">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
bpm-&gt;duration&nbsp;&nbsp;</td>
<td class="lambda-list">
beats tempo</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Converts a duration in number of beats and the corresponding tempo in BPM into a duration in seconds. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233988">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
isolate-time-signatures&nbsp;&nbsp;</td>
<td class="lambda-list">
ts-forms</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Transforms time signatures `ts-forms' so that each resulting time signature denotes only a single bar. 
 </p>
<p>
</p>
<h4>
Examples: </h4>
<pre>
    (isolate-time-signatures '((3 4 2) (2 4 1))) 
     =&gt; ((3 4 1) (3 4 1) (2 4 1)) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233989">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
length-&gt;time-signature&nbsp;&nbsp;</td>
<td class="lambda-list">
sequence</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Expects any OMN sequence, extracts its rhythm, and translates each note value in a time signature of the same length. 
 </p>
<p>
</p>
<h4>
Examples: </h4>
<pre>
    (rhythm-to-time-sig-sequence '(3/4 1/4 1/2)) 
     =&gt; ((3 4 1) (1 4 1) (2 4 1)) </pre>
<p>
</p>
<h4>
See Also: </h4>
<p>
This function is largely the complement of the Opusmodus buildin function `time-signature-length'. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233990">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
metric-shift&nbsp;&nbsp;</td>
<td class="lambda-list">
l lengths</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Appends `l' (a length or omn) before `lengths' (a list of lengths or omn), but maintains the metric structure, i.e., the function shifts `lengths' metrically 'to the right' by `l'. 
 </p>
<p>
Returns an OMN form if lengths is an OMN form, otherwise a length form. 
 
 </p>
<h4>
Examples: </h4>
<p>
</p>
<pre>
    (metric-shift '-h '((q q q q) (q q q q))) </pre>
<p>
</p>
<pre>
    (metric-shift '(h g4 e) '((q c4 q d4 q e4 q f4) (q c4 q d4 q e4 q f4))) </pre>
<p>
</p>
<h4>
BUGS: </h4>
<p>
If `lengths' is only a list of length values and not a full OMN sequence, then other parameters in `l' are ignored. 
 
 </p>
<pre>
    (metric-shift '(h d4) '((q q q q) (q q q q))) </pre>
<p>
</p>
<h4>
See Also: </h4>
<p>
assemble-seq (but that does not shift across bars) 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233991">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
shift-meter-boundaries&nbsp;&nbsp;</td>
<td class="lambda-list">
lengths positions</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Shift meter boundaries (sublist lengths) between bars in `lengths', by given number of positions (number of notes or rests) forwards or backwards. Such meter transformations can be useful, e.g., to prepare music for inserting durational accents expressing syncopations, and then afterwards moving the meter boundaries back to their original positions (e.g., using `copy-time-signature' with the original sequence). 
 </p>
<p>
Note that resulting meter changes may occur even within tuplets, though Opusmodus may not support notating the result. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
length: list of OMN length values, must be nested 
 </p>
</li>
<li>
<p>
positions (lists of ints, length most be one shorter than number of bars/sublists in lengths): amount by how many note values the bar line should be moved to the left (negative number) or to the right (positive number). `positions' is circled through to meet the length of `lengths'. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<pre>
    (shift-meter-boundaries '((1/18 1/18 1/18 1/18 1/18 1/18 1/18 1/18 1/18) 
                               (1/16 1/16 1/16 1/16 1/16 1/16 1/16 -1/16) 
                               (-1/14 1/14 1/14 1/14 1/14 1/14 1/14)  
                               (q -q))  
                             '(0 -1 1)) </pre>
<p>
</p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233992">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
insert-into-bar&nbsp;&nbsp;</td>
<td class="lambda-list">
positions new lengths <em>&amp;key</em> section seed</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Inserts item(s) 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
positions (list of position values): either symbol 's (start), 'e (end) or '? (random position), or integer specifying position. 
 </p>
</li>
<li>
<p>
new: list of OMN length values to be inserted, can be nested or partially nested. 
 </p>
</li>
<li>
<p>
lengths: list of OMN length values, must be nested. 
 `positions' and `new' is circled through to meet the length of `lengths' or `section'. 
 </p>
</li>
<li>
<p>
section (list of ints): selected sublists to process. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<pre>
    (insert-into-bar '(s e) '(q (e e)) '((h) (h) (h))) 
     (insert-into-bar '(?) '(q (e e)) '((h) (h) (h)) :section '(1 2) :seed 1) </pre>
<p>
</p>
<h4>
See Also: </h4>
<p>
Opusmodus builtin `position-insert'. 
 </p>
</div>
</div>
</div>
<div class="cludg-footer">
Generated by&nbsp;<a href="mailto:ihatchondo@common-lisp.net" lang="en">
CLDOC</a>
- 2018-08-30 10:30:17</div>
</body>
</html>
