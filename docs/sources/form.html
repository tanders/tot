<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
<head>
<link rel="Stylesheet" type="text/css" href="../cludg.css"/>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
<title>
form</title>
</head>
<body>
<div id="navbar">
<table cellspacing="0" cellpadding="0" border="0" style="width: 100%;">
<colgroup span="3">
<col width="0*"/>
<col width="0*"/>
<col width="1*"/>
</colgroup>
<tr>
<td align="left" valign="baseline">
<a href="constraints.html">
Prev:&nbsp;constraints</a>
<br/>
<a href="orchestration.html">
Next:&nbsp;orchestration</a>
</td>
<td>
&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td align="left" valign="baseline">
<span class="upchain">
<b>
form</b>
<br/>
<a href="../index.html">
Index</a>
</span>
&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div class="cludg-doc-body">
<h2>
form
</h2>
<table style="width: 100%;" class="summary-table">
<tr class="table-heading-color">
<th class="summary" colspan="2">
Function summary</th>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="form.html#_g233898">
alternate-fenvs</a>
</td>
<td class="summary">
ids ns fenv-lists <em>&amp;key</em> (interpolation :steps)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="form.html#_g233902">
alternate-omn-fenvs</a>
</td>
<td class="summary">
ids no-of-sublists omn-fenv-lists parameters sequence <em>&amp;key</em> (keep-articulations? t) (interpolation :steps) (hairpins? nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="form.html#_g233896">
alternate-omns</a>
</td>
<td class="summary">
ids seqs-of-seqs <em>&amp;key</em> (append? nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="form.html#_g233900">
alternate-subseq-fenvs</a>
</td>
<td class="summary">
ids no-of-sublists fenv-lists parameter sequence <em>&amp;key</em> (min-vel 'pp) (max-vel 'ff) (articulation-maps nil) (keep-articulations? t) (interpolation :steps) (hairpins? nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="form.html#_g233895">
condense</a>
</td>
<td class="summary">
sequence test <em>&amp;key</em> (section nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="form.html#_g233894">
developing-substitute</a>
</td>
<td class="summary">
map sequence otherwise</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="form.html#_g233901">
omn-&gt;fenv</a>
</td>
<td class="summary">
parameter sequence <em>&amp;key</em> (type :steps)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="form.html#_g233903">
rotate-omn</a>
</td>
<td class="summary">
n sequence <em>&amp;key</em> (parameter :pitch) (flat t) (section nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="form.html#_g233897">
_alternate-omns-aux</a>
</td>
<td class="summary">
ids hash append?</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="form.html#_g233899">
_map-sublist-subseqs</a>
</td>
<td class="summary">
no-of-sublists sequence fn</td>
</tr>
</table>
<div class="defun">
<div class="defunsignatures">
<a id="_g233894">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
developing-substitute&nbsp;&nbsp;</td>
<td class="lambda-list">
map sequence otherwise</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Returns a transformation of `sequence', where elements that match entries given in `map' are replaced with given new items, and -- if not contained in map -- with an `otherwise' element. However, this function allows for replacements that develop over time and where the sequence of the developments could be generated algorithmically by other functions: When multiple new and otherwise replacements are given, these are used by and by in their given order (circulating, if the end of the given sequence is reached). 
 
 Replacements in the mapping can also be specified by functions returning the necessary replacement. 
 </p>
<p>
Note that sequence elements to replace can be arbitrary values, including subsequences. 
 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
map: old-new pairs (list of two-element lists) 
 </p>
</li>
<li>
<p>
sequence: sequence (list) to transform 
 </p>
</li>
<li>
<p>
otherwise: flat list of alternative replacements. Per sublist, only a single replacement value is chosen. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<pre>
    (developing-substitute '((1 (a b c)) 
       			     (2 (h i j))) 
                            '(1 1 2 1 3 2 1) 
                            '(x y z)) 
     =&gt; (a b h c x i a) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233895">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
condense&nbsp;&nbsp;</td>
<td class="lambda-list">
sequence test <em>&amp;key</em> (section nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Beethoven-like condensation of music. All notes for which a given test function returns `nil' are removed, and their preceeding note is extended by their duration. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
test: Boolean function expecting individual parameters of each note in `OMN' 
 </p>
</li>
<li>
<p>
sequence: An OMN sequence 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<p>
</p>
<pre>
    (setf my-motif '((q. c4 e d4 q. e4 e f4) (h g4 -h))) </pre>
<p>
</p>
<pre>
    (condense my-motif 
               #'(lambda (dur pitch &amp;rest other-args)   
                   (&gt; (omn-encode dur) 1/4))) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233896">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
alternate-omns&nbsp;&nbsp;</td>
<td class="lambda-list">
ids seqs-of-seqs <em>&amp;key</em> (append? nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
This function alternates between sublists of multiple omn sequences. It can be useful, e.g., to switch between different musical characteristics, but have some kind of development within each characteristic. This is a powerful function for organising musical form on a higher level. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
ids (list of 0-based integers): indicating the position of OMN expressions in seqs-of-seqs. 
 </p>
</li>
<li>
<p>
seqs-of-seqs (list of lists of OMN sequences or plain OMN parameters): specifies material between which to switch. The top-level list positions indicate the different materials pointed to by `ids'. The next level specifies the order in which material will be included when `ids' contains repetitions of an id. This order is circling. The lowest level is the actual material either as a flat list (each a single bar), or as a nested list (multiple bars). In case of a nested list at the lowest level you likely want to set `append' to T. 
 </p>
</li>
<li>
<p>
append? (Boolean): whether or not nested OMN sequences should be appended instead of been combined in a list. 
 </p>
</li>
</ul>
<p>
</p>
<h4>
Examples: </h4>
<p>
The following example demonstrates the use of the arguments `ids' and `seqs-of-seqs' with a flat sequence of note lengths. Note the nesting of `seqs-of-seqs', as explained by the comments. 
 
 </p>
<pre>
    (alternate-omns 
      ;; sequence of IDs 
      '(0 0 1 1 0 0) 
      '(;; ID 0 material/gestures  
        (;; for first occurance of ID 0 (and again, when circling) 
         (h q q) 
         ;; second occurance of ID 0 etc. 
         (h. e e)) 
        ;; ID 1 material//gestures (only one segment, repeated always) 
        ((e e e e e e e e)) 
        )) 
     ; =&gt; ((h q q) (h. e e) (e e e e e e e e) (e e e e e e e e) (h q q) (h. e e)) </pre>
<p>
Now, the power of algorithmic composition lies in the fact that each of these arguments can be algorithmically generated. The next example demontrates that. It also demonstrates how the materials/gestures can be OMN expressions with multiple parameters. Still, each of these gestures consist in a single bar (gestures are not nested, though they are nested within two list levels). 
 </p>
<p>
</p>
<pre>
    (alternate-omns  
      ;; random sequence of IDs 
      (gen-eval 10 '(rnd-pick '(0 1))) 
      (list  
       ;; sequence of first kind of musical gestures 
       (make-omn 
        :length (length-rest-series 
     	    (rnd-sample 7 '(7 8 9)) 
     	    (length-divide 3 2 
     			   (rnd-sample 7 '((q q q) (h e e) (h.) (h q))))) 
        :pitch '(d4 e4 f4 g4) 
        :velocity '(pp)) 
       ;; sequence of second kind of musical gestures 
       (make-omn 
        :length '(s s s s) 
        :pitch (gen-rotate :right '(c5 d5 f5 a5 g5 e5) :type :seq) 
        :velocity '(ff) 
        :span :pitch))) </pre>
<p>
Remember that resulting OMN expressions can be 're-barred'. This is useful, e.g., for gestures that exceed a single bar but are still stored in a flat list (again, nested within two list levels). 
 </p>
<p>
</p>
<pre>
    (omn-to-time-signature  
      (alternate-omns 
       '(0 0 1 0 1 0 1 1 0 0 1 1 1) 
       (list 
        (make-omn  
         :length (gen-rotate :left '(-1/20 1/20 1/20 1/20 1/20) :type :seq) 
         :pitch '(d4 e4 f4 g4) 
         :velocity '(ff)) 
        (make-omn 
         :length '(q e e) 
         :pitch (gen-rotate :left '(c5 e5 f5) :type :seq) 
         :velocity '(pp pp) 
         :attribute '(ten stacc stacc) 
         :span :pitch))) 
      '(4 4)) </pre>
<p>
Alternatively, it is possible to use gestures that consists of nested lists for representing bars (still nested within two higher list levels). In that case, you typically want to set `append?' to T so that the result is a standard OMN sequence with only a single level of nesting, as shown below. 
 </p>
<p>
</p>
<pre>
    (alternate-omns '(0 0 1 1 0 0)  
                     '((;; one nested gestures, circled in case of repeated IDs 
     		       ((-h q c4 p leg) (q. f4 leg e g4 leg q a4 leg) (h. g4))) 
                       (;; one nested gestures 
     		       ((q g4 f leg c5 leg e c4 stacc d4 stacc e4 f4 stacc) (q g4 stacc -h.)))) 
                     :append? T) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233897">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
_alternate-omns-aux&nbsp;&nbsp;</td>
<td class="lambda-list">
ids hash append?</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Aux def 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233898">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
alternate-fenvs&nbsp;&nbsp;</td>
<td class="lambda-list">
ids ns fenv-lists <em>&amp;key</em> (interpolation :steps)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Alternate between fenvs and sample the fenvs; the result is a list of lists of numbers (fenv values). A fenv is a particularly flexible envelope, see my fenv library for details. 
 </p>
<p>
For convenience, fenvs can also be specified simply as lists of numbers (x-values). 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
ids (list of 0-based integers): indicating the position of fenvs. 
 </p>
</li>
<li>
<p>
ns (list of integers): indicates number of samples per fenv. `ids' and `ns' should have the same length. 
 </p>
</li>
<li>
<p>
fenv-lists (list of fenvs, or list of lists of fenvs): specifies fenvs between which to switch. If `fenv-lists' is a flat list of fenvs, then `ids' simply access the fenvs at those postions. If `fenv-lists' is nested, then `ids' indicate the top-level list positions of `fenv-lists'. The lower-level list of fenvs indicates alternatives from which to choose in order. So, when there is a repetition of integers in `ids', always the next fenv in the respective list of alternatives is choses. This order is circling. 
 Remember that fenvs can be specified as a number sequence as well. 
 </p>
</li>
<li>
<p>
interpolation (either <span class="keyword">
:steps </span>
or :linear): in case fenvs are specified as lists of numbers, the `interpolation' indicates the type of fenv created. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<p>
Using lists of integers, internally translated into fenvs. The result here is rather similar to the input, but with lists of different lengths. 
 </p>
<pre>
    (alternate-fenvs '(0 1 0) '(3 3 4)  
     		 '((1 2 3 4) 
     		   (10 8 6 4))) 
     =&gt; ((1 3 4) (10 6 4) (1 2 3 4)) </pre>
<p>
For ns greater than the length of the number lists representing the fenvs, the interpolation method makes a difference. 
 </p>
<pre>
    (alternate-fenvs '(0 1 0) '(6 8 6)  
     		 '((1 3 2) 
     		   (10 4))) 
     =&gt; ((1 1 3 3 2 2) (10 10 10 10 4 4 4 4) (1 1 3 3 2 2)) </pre>
<p>
</p>
<pre>
    (alternate-fenvs '(0 1 0) '(6 8 6)  
     		 '((1 3 2) 
     		   (10 4)) 
     		 :interpolation :linear) 
     =&gt; ((1 9/5 13/5 14/5 12/5 2) (10 64/7 58/7 52/7 46/7 40/7 34/7 4) (1 9/5 13/5 14/5 12/5 2)) </pre>
<p>
When specifying fenvs directly, the full range of fenvs are available. 
 </p>
<pre>
    (alternate-fenvs '(0 1 0) '(3 3 4)  
     		 (list (fenv:sin-fenv (0 1) (1 0)) 
     		       (fenv:sin-fenv (0 0) (1 1)))) </pre>
<p>
An example with double-nested fenvs 
 </p>
<pre>
    (alternate-fenvs '(0 0 1 1 0 0) '(4 4 4 4 4 4)   
          		 '(((1 2 3 4) (2 3 4 5) (3 4 5 6))  
          		   ((10 8 6 4) (11 9 7 5)))) 
     =&gt; ((1 2 3 4) (2 3 4 5) (10 8 6 4) (11 9 7 5) (3 4 5 6) (1 2 3 4)) </pre>
<p>
For more examples with nested lists of fenvs in `fenv-lists' compare the use of (double) nested OMN sequences in `alternate-omns' above. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233899">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
_map-sublist-subseqs&nbsp;&nbsp;</td>
<td class="lambda-list">
no-of-sublists sequence fn</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
aux 
 fn is a function expecting a list of sublists of sequence 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233900">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
alternate-subseq-fenvs&nbsp;&nbsp;</td>
<td class="lambda-list">
ids no-of-sublists fenv-lists parameter sequence <em>&amp;key</em> (min-vel 'pp) (max-vel 'ff) (articulation-maps nil) (keep-articulations? t) (interpolation :steps) (hairpins? nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
This function adds (or replaces) a given `parameter' to (of) an OMN `sequence', where this new parameter sequence follows a concatenation of fenvs. A fenv is a particularly flexible envelope, see my fenv library for details. 
 </p>
<p>
Like `alternate-omns', the present function is useful for switching between different musical characteristics, while having some kind of development within each characteristic. It is a powerful function for organising musical form on a higher level. 
 </p>
<p>
One of the particular expressive powers of this function is that characteristics defined by fenvs (`fenv-lists') can be applied to sublists (bars) in `sequence' of different lengths. For example, the same overall gestus can be applied to a bar of three but all four or five notes. (Nevertheless, it does not allow to change the number of elements in `sequence'.) 
 </p>
<p>
For convenience, fenvs can also be specified simply as lists of numbers (x-values). 
 </p>
<p>
See also the function `alternate-omn-fenvs', which is similar but more easy to use. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
ids (list of 0-based integers): indicating order of positions of fenvs to choose from `fenv-lists'. 
 </p>
</li>
<li>
<p>
no-of-sublists (integer or list of integers): indicates how many consecutive sublists (quasi bars) of `sequence' each fenv shapes. The number of samples created from each fenv is the product of the length of the sublist in question and the respective `no-of-sublists' value. 
 </p>
</li>
<li>
<p>
fenv-lists (list of fenvs, or list of lists of fenvs): specifies fenvs between which to switch. If `fenv-lists' is a flat list of fenvs, then `ids' simply access the fenvs at those positions. If `fenv-lists' is nested, then `ids' indicate the top-level list positions of `fenv-lists'. The lower-level list of fenvs indicates alternatives from which to choose in order. So, when there is a repetition of integers in `ids', always the next fenv in the respective list of alternatives is choses. This order is circling. 
 </p>
</li>
<li>
<p>
parameter (keyword): the parameter the fenvs overwrite in `sequence', can be <span class="keyword">
:length, </span>
<span class="keyword">
:pitch, </span>
<span class="keyword">
:velocity </span>
or <span class="keyword">
:articulation. </span>
As fenv values are always numeric, they have to be translated into the corresponding parameter. Fenvs values for length values should be ratios (they are translated to ratios internally, but complex ratios can lead to difficulties with notation); fenv values for pitches are MIDI note numbers; fenv values for velocities depend on `min-vel' and `max-vel'; and articulations are the rounded position of elements in the `articulation-maps'. 
 </p>
</li>
<li>
<p>
sequence: OMN sequence to transform, must be nested. 
 </p>
</li>
<li>
<p>
min-vel/max-vel (OMN velocity symbol like 'p or 'ff): in case `parameter' is <span class="keyword">
:velocity, </span>
these args set the minimum and maximum velocity in the result. 
 </p>
</li>
<li>
<p>
articulation-maps (list of list of OMN articulation symbols): in case `parameter' is <span class="keyword">
:articulation, </span>
this arg specifies the articulations that rounded fenv values mean. For example, if `articulation-maps' is '(stacc ten) then the fenv value 0 results in a staccato and 1 in a tenuto. 
 </p>
</li>
<li>
<p>
keep-articulations? (Boolean): if T, existing articulations of `sequence' are retained and new articulations are added, otherwise new articulations overwrite the existing ones. 
 </p>
</li>
<li>
<p>
interpolation (either `:steps' or `:linear'): in case fenvs are specified as lists of numbers, the `interpolation' indicates the type of fenv created. 
 </p>
</li>
<li>
<p>
hairpins? (Boolean): In case `parameter' is `:velocity' you can set that the dynamics are connected with crescendo and diminuendo hairpins, which may make particularly sense if `interpolation' is set to `:linear'. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<p>
Lists of integers can be used instead of fenvs for convenience. 
 </p>
<pre>
    (alternate-subseq-fenvs '(0 1 1 0) 
     			'(2 1 2 1) 
     			;; two envelopes, defined as linearly interpolated number lists 
     			'((72 48) (60 84)) 
     			:pitch 
     			(gen-repeat 3 '((h h) (q q q q))) 
     			:interpolation :linear) </pre>
<p>
When specifying fenvs directly, the full range of fenvs and their transformations are available. 
 </p>
<pre>
    (alternate-subseq-fenvs '(0 1 1 0) 
     			'(2 1 2 1) 
     			(list (fenv:sin-fenv (0 72) (1 48)) 
     			      (fenv:sin-fenv (0 60) (1 84))) 
     			:pitch 
     			(gen-repeat 3 '((h h) (q q q q)))) </pre>
<p>
An example with velocities 
 </p>
<pre>
    (alternate-subseq-fenvs '(0 1 1 0) 
     			'(1 1 1 1) 
     			(list (omn-&gt;fenv :velocity '(p p p ff) :type :steps) 
     			      (omn-&gt;fenv :velocity '(mf pp pp pp) :type :steps)) 
     			:velocity 
     			(gen-repeat 3 '((h h) (q q q q)))) </pre>
<p>
An example with double-nested lists. 
 </p>
<pre>
    (alternate-subseq-fenvs '(0 0 1 1 0 0)  
          			'(1 1 1 1 1 1)  
          			;; two envelopes, defined as linearly interpolated number lists  
          			'(((72 60) (71 59) (70 58)) 
                                   ((72 84) (74 86))) 
          			:pitch  
          			(gen-repeat 3 '((h h) (q q q q)))  
          			:interpolation :linear) 
     =&gt; ((h c5 c3) (q b4 eb4 g3 b2) (h c4 c6) (q d4 bb4 fs5 d6) (h bb4 bb2) (q c5 e4 gs3 c3)) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233901">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
omn-&gt;fenv&nbsp;&nbsp;</td>
<td class="lambda-list">
parameter sequence <em>&amp;key</em> (type :steps)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Translates one of the parameters of the OMN `sequence' into a number sequence, which is then translated into a fenv. A fenv is a particularly flexible envelope, see my fenv library for details. 
 </p>
<p>
This function is useful, e.g., for quasi motific variation, where the number of notes in the result changes but the result still follows the overall shape (profile) of the given music. 
 </p>
<p>
Usually, you do not want to use this function directly, but instead use the function `alternate-omn-fenvs', which is less low-level and therefore more easy to use. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
parameter: an OMN parameter keyword like <span class="keyword">
:length </span>
or <span class="keyword">
:pitch </span>

 </p>
</li>
<li>
<p>
sequence: either full OMN sequence or sequence of the respective OMN parameters 
 </p>
</li>
<li>
<p>
type: how to interpolate between parameter values. Can be <span class="keyword">
:steps </span>
(a step function, i.e. parameter values are hold by the fenv unti the next value) or <span class="keyword">
:linear </span>
(linear interpolation). 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<p>
A six-note OMN sequence with multiple parameters used for several examples 
 </p>
<pre>
    (setf sequence '((h c5 f ten q g4 mp stacc) (q b4 ff ten q g4 f stacc q d4 mp stacc) (h. g4 f tr2))) </pre>
<p>
Translate the note values of this six-note sequence into a sequence of five note values. 
 </p>
<pre>
    (fenv:fenv-&gt;list (omn-&gt;fenv :length sequence) 5) </pre>
<p>
Translate the pitches of this six-note sequence into a sequence of five pitches. 
 </p>
<pre>
    (midi-to-pitch (fenv:fenv-&gt;list (omn-&gt;fenv :pitch sequence) 5)) </pre>
<p>
Translate the pitches of this six-note sequence into a sequence of eight pitches. 
 </p>
<pre>
    (midi-to-pitch (mapcar #'round (fenv:fenv-&gt;list (omn-&gt;fenv :pitch sequence :type :linear) 8)))   </pre>
<p>
Translate the note dynamics of this six-note sequence into a sequence of 9 dynamics without interpolation. 
 </p>
<pre>
    (get-velocity (mapcar #'round (fenv:fenv-&gt;list (omn-&gt;fenv :velocity sequence :type :steps) 9)) :type :symbol) </pre>
<p>
Translate the note dynamics of this six-note sequence into a sequence of 5 dynamics, but linearily interpolating between the original xones. 
 </p>
<pre>
    (get-velocity (mapcar #'round (fenv:fenv-&gt;list (omn-&gt;fenv :velocity sequence :type :linear) 5)) :type :symbol) </pre>
<p>
Translate the articulations of this six-note sequence into a sequence of 7 articulations. 
 </p>
<pre>
    (multiple-value-bind (fenv arts-set) 
         (omn-&gt;fenv :articulation (flatten sequence)) 
       ;; inefficient with list 
       (mapcar #'(lambda (i) (nth i arts-set))  
     	    (fenv:fenv-&gt;list fenv 7))) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233902">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
alternate-omn-fenvs&nbsp;&nbsp;</td>
<td class="lambda-list">
ids no-of-sublists omn-fenv-lists parameters sequence <em>&amp;key</em> (keep-articulations? t) (interpolation :steps) (hairpins? nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
This function adds (or replaces) one or more given `parameters' to (of) an OMN `sequence', where this new parameter sequence follows a concatenation of fenvs. A fenv is a particularly flexible envelope, see my fenv library for details. However, for this function musical characteristics in `omn-fenv-lists' are defined by OMN expressions instead, and fenvs are only used in the background. 
 </p>
<p>
Like `alternate-omns', the present function is useful for switching between different musical characteristics, while having some kind of development within each characteristic. It is a powerful function for organising musical form on a higher level. 
 </p>
<p>
One of the particular expressive powers of this function is that characteristics defined by fenvs (`fenv-lists') can be applied to sublists (bars) in `sequence' of different lengths. For example, the same overall gestus can be applied to a bar of three but all four or five notes. (Nevertheless, it does not allow to change the number of elements in `sequence'.) 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
ids (list of 0-based integers): indicating order of positions of fenvs to choose from `omn-fenv-lists'. 
 </p>
</li>
<li>
<p>
no-of-sublists (integer or list of integers): indicates how many consecutive sublists (quasi bars) of `sequence' each fenv shapes. The number of samples created from each fenv is the product of the length of the sublist in question and the respective `no-of-sublists' value. 
 </p>
</li>
<li>
<p>
omn-fenv-lists (list of flat OMN expression lists, or list of lists of flat OMN expression lists): specifies characteristics between which to switch (transformed into fenvs in the background). If `omn-fenv-lists' is a list of OMN expression lists, then `ids' simply access the fenvs at those positions. If `omn-fenv-lists' is further nested, then `ids' indicate the top-level list positions of `omn-fenv-lists'. The lower-level list of fenvs indicates alternatives from which to choose in order. So, when there is a repetition of integers in `ids', always the next fenv in the respective list of alternatives is choses. This order is circling. 
 </p>
</li>
<li>
<p>
parameter (keyword or list of keywords): the parameter the fenvs overwrite in `sequence', can be <span class="keyword">
:length, </span>
<span class="keyword">
:pitch, </span>
<span class="keyword">
:velocity </span>
or <span class="keyword">
:articulation. </span>

 </p>
</li>
<li>
<p>
sequence: OMN sequence to transform, must be nested. 
 </p>
</li>
<li>
<p>
keep-articulations? (Boolean): if T, existing articulations of `sequence' are retained and new articulations are added, otherwise new articulations overwrite the existing ones. 
 </p>
</li>
<li>
<p>
interpolation (either `:steps' or `:linear'): `interpolation' indicates the type of fenv created (interpolation between the numeric representation of OMN parameter values or not). 
 </p>
</li>
<li>
<p>
hairpins? (Boolean): In case `parameter' is `:velocity' you can set that the dynamics are connected with crescendo and diminuendo hairpins, which may make particularly sense if `interpolation' is set to `:linear'. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<p>
TODO: 
 </p>
<p>
</p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g233903">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
rotate-omn&nbsp;&nbsp;</td>
<td class="lambda-list">
n sequence <em>&amp;key</em> (parameter :pitch) (flat t) (section nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Rotate the OMN `sequence' by `n' positions. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
n: an integer (rotation number, positive or negative) or a list of ints. The keywords <span class="keyword">
:left </span>
and <span class="keyword">
:right </span>
are equivalents of the integer values -1 and 1. If `n' is a list then `flat' must be nil. 
 </p>
</li>
<li>
<p>
sequence: OMN expression. 
 </p>
</li>
<li>
<p>
parameter (keyword): which parameter to rotate (e.g., <span class="keyword">
:length, </span>
<span class="keyword">
:pitch...). </span>

 </p>
</li>
<li>
<p>
flat (Boolean): whether to rotate the full flattened sequence (T) or subsequences. 
 </p>
</li>
<li>
<p>
section (list of ints): positions of sublists to process. This argument is ignored if flat is T. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<p>
</p>
<pre>
    (rotate-omn :right '((-h q c4) (q. f4 e g4 q a4) (h. g4))) 
      
     (rotate-omn :left '((-h q c4) (q. f4 e g4 q a4) (h. g4)) :parameter :length) 
      
     (rotate-omn 2 '((-h q c4) (q. f4 e g4 q a4) (h. g4)) :section '(1 2) :flat nil) </pre>
<p>
The following examples are rotating subsequences separately. 
 </p>
<p>
</p>
<pre>
    (rotate-omn '(0 1 2) '((-h e c4 e4) (q. f4 e g4 q a4) (q g4 f4 e e4 d4)) :flat nil) ; default parameter pitch 
      
     (rotate-omn '(0 1 2) '((-h e c4 e4) (q. f4 e g4 q a4) (q g4 f4 e e4 d4)) :flat nil :parameter :length) 
      
     (rotate-omn '(2 1) '((-h e c4 e4) (q. f4 e g4 q a4) (q g4 f4 e e4 d4)) :section '(1 2) :flat nil :parameter :length) </pre>
</div>
</div>
</div>
<div class="cludg-footer">
Generated by&nbsp;<a href="mailto:ihatchondo@common-lisp.net" lang="en">
CLDOC</a>
- 2018-08-08 01:21:37</div>
</body>
</html>
