<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
<head>
<link rel="Stylesheet" type="text/css" href="../cludg.css"/>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
<title>
OMN-utils</title>
</head>
<body>
<div id="navbar">
<table cellspacing="0" cellpadding="0" border="0" style="width: 100%;">
<colgroup span="3">
<col width="0*"/>
<col width="0*"/>
<col width="1*"/>
</colgroup>
<tr>
<td align="left" valign="baseline">
<a href="utils.html">
Prev:&nbsp;utils</a>
<br/>
<a href="score.html">
Next:&nbsp;score</a>
</td>
<td>
&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td align="left" valign="baseline">
<span class="upchain">
<b>
OMN-utils</b>
<br/>
<a href="../index.html">
Index</a>
</span>
&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div class="cludg-doc-body">
<h2>
OMN-utils
</h2>
<table style="width: 100%;" class="summary-table">
<tr class="table-heading-color">
<th class="summary" colspan="2">
Function summary</th>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339545">
copy-time-signature</a>
</td>
<td class="summary">
music-with-time-signature music-to-rebar</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339552">
count-notes</a>
</td>
<td class="summary">
notes</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339547">
edit-omn</a>
</td>
<td class="summary">
type notation fun <em>&amp;key</em> (flat nil) (swallow nil) (section nil) (additional-args nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339558">
ensure-double-list</a>
</td>
<td class="summary">
x</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339551">
flattened-length-adjust</a>
</td>
<td class="summary">
duration sequence</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339555">
length-add</a>
</td>
<td class="summary">
<em>&amp;rest</em> length-values</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339554">
length-subtract</a>
</td>
<td class="summary">
<em>&amp;rest</em> length-values</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339542">
map-events</a>
</td>
<td class="summary">
fn sequence <em>&amp;key</em> (test #'(lambda (<em>&amp;rest</em> args) (declare (ignore args)) t)) flat section exclude</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339544">
map-omn</a>
</td>
<td class="summary">
fn omn-expr</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339549">
map-position-in-bar</a>
</td>
<td class="summary">
position type sequence fun <em>&amp;key</em> (section nil)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339546">
map-section</a>
</td>
<td class="summary">
function sequence <em>&amp;key</em> section exclude section-args shared-args</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339557">
mk-seed</a>
</td>
<td class="summary">
<em>&amp;optional</em> seed</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339553">
phrase-lengths</a>
</td>
<td class="summary">
lengths</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339543">
process-element</a>
</td>
<td class="summary">
fn element args</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339548">
process-omn2</a>
</td>
<td class="summary">
type function sequence <em>&amp;key</em> flatten flat (span :length) swallow section exclude</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339556">
rnd-section</a>
</td>
<td class="summary">
section-range probability <em>&amp;key</em> seed</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="OMN-utils.html#_g339550">
total-duration</a>
</td>
<td class="summary">
sequence <em>&amp;optional</em> float?</td>
</tr>
</table>
<div class="defun">
<div class="defunsignatures">
<a id="_g339542">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
map-events&nbsp;&nbsp;</td>
<td class="lambda-list">
fn sequence <em>&amp;key</em> (test #'(lambda (<em>&amp;rest</em> args) (declare (ignore args)) t)) flat section exclude</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Every event for which the function `test' returns true is transformed by the function `fn'. In the background, sequence is transformed into a list of events, where each note is represented by a list of the parameters length, pitch, velocity, and articulation. 
 </p>
<p>
Rests are skipped unprocessed. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
fn: function expecting and returning a single event, i.e. the function expects the arguments length, pitch, velocity and articulation of individual elements. 
 </p>
</li>
<li>
<p>
sequence: an OMN sequence 
 </p>
</li>
<li>
<p>
test: Boolean function expecting a single event. By default, all elements are processed. 
 </p>
</li>
<li>
<p>
flat (Boolean): whether or not to flatten sequence before processing. 
 </p>
</li>
<li>
<p>
section (list of ints): 0-based positions of bars (sublists) in nested `sequence' to which `fn' is applied. 
 </p>
</li>
<li>
<p>
exclude (list of ints): 0-based positions of bars (sublists) in nested `sequence' to which `fn' is *not* applied. Only either `section' or `exclude' should be specified, otherwise `exclude' is ignored. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<p>
Reduce all events with velocity p to velocity pp 
 </p>
<pre>
    (map-events 
      #'(lambda (l p v a) (list l p 'pp a)) 
      '((-e s bb3 f marc a3 leg g3 p leg gs3 leg g3 leg a3 leg) (q fs3 f ten -q)) 
      :test #'(lambda (l p v a) (eql v 'p))) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339543">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
process-element&nbsp;&nbsp;</td>
<td class="lambda-list">
fn element args</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Many Opusmodus functions are defined to work only with lists. This function is intended to help when you want to instead process a single element with such a function. 
 </p>
<p>
</p>
<h4>
Examples: </h4>
<p>
Transpose a single element with pitch-transpose 
 </p>
<pre>
    (process-element #'pitch-transpose 'c4 '(2 _)) </pre>
<p>
Without this function, the call above would look as follows. 
 </p>
<pre>
    (first (pitch-transpose 2 (list 'c4))) </pre>
<p>
It is a matter of taste/style, which approach you prefer <span class="keyword">
:) </span>

 </p>
<p>
Of course, it might be better if instead Opusmodus functions would simply support single OMN notation elements as well. 
 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339544">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
map-omn&nbsp;&nbsp;</td>
<td class="lambda-list">
fn omn-expr</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Variant of mapcar for omn expressions, intended for creating variations of omn-expr. Applies function fn to every note in omn-expr (a flat OMN list). fn must exect four arguments (a length, pitch, velocity and articution) and returns a list of four values (a length, pitch, velocity and articution). 
 </p>
<p>
NOTE: This was one of my first Opusmodus function definitions, and while it works it is not as refined as some later functions <span class="keyword">
:) </span>

 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
fn: a function expecting four arguments (a length, pitch, velocity and articulation) and returning a list of four values (a length, pitch, velocity and articulation). 
 </p>
</li>
<li>
<p>
omn-expr: an OMN expression 
 </p>
</li>
</ul>
<p>
</p>
<h4>
Examples: </h4>
<p>
</p>
<pre>
    (map-omn #'(lambda (length pitch velocity articulation) 
                  (list length  
                        pitch  
                        ;; replace tasto dynamics by fff 
                        (if (equal articulation 'tasto) 
                          'fff 
                          velocity) 
                        articulation)) 
              '(e. c4 pppp tasto d4 ponte e4)) 
     =&gt; (e. c4 fff tasto d4 pppp ponte e4) </pre>
<p>
</p>
<pre>
    (map-omn #'(lambda (length pitch velocity articulation) 
                  (list length  
                              (if (member 'slap (disassemble-articulations articulation)) 
                                'c4 
                                pitch) 
                              velocity 
                              articulation)) 
              '((q b4 f slap+stacc -h q bb4 slap+stacc -h) (q gs4 slap+stacc -h) (q bb4 slap+stacc c5 mp ord d5 q. f5 e eb5 q d5) (-q c5 g4 h fs4 q eb5 stacc) (q c5 f slap+stacc -h q. g4 mp ord e f5 q e5) (q f5 cs5 f4 h d5 -q))) </pre>
<p>
</p>
<h4>
BUGS: </h4>
<p>
Does not work if omn-expr contains rest. 
 </p>
<p>
Problem: omn does not provide any values for rests. 
 Possible solution: couple note durations with their respective params, but leave rests without. Then skip rests in the processing unchanged. 
 BTW: This process looses articulations on rests, like fermata. 
 </p>
<p>
</p>
<h4>
Notes: </h4>
<p>
See also the Opusmodus built-in function `single-events': looping (or mapping) over its result has similar effect. 
 </p>
<p>
</p>
<h4>
See Also: </h4>
<p>
<a href="OMN-utils.html#_g339542">
map-events</a>

 </p>
<p>
</p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339545">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
copy-time-signature&nbsp;&nbsp;</td>
<td class="lambda-list">
music-with-time-signature music-to-rebar</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Rebars `music-to-rebar' so that it fits the meter of `music-with-time-signature'. If music-with-time-signature is a flat list, no rebarring happens. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339546">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
map-section&nbsp;&nbsp;</td>
<td class="lambda-list">
function sequence <em>&amp;key</em> section exclude section-args shared-args</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Apply a function to only selected bars (sublists) in an OMN sequence. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
function: function to apply to sublists in `sequence' 
 </p>
</li>
<li>
<p>
sequence: nested list of OMN parameters or full OMN expressions 
 </p>
</li>
<li>
<p>
section (list of ints): 0-based positions of bars (sublists) in `sequence' to which `function' is applied. 
 </p>
</li>
<li>
<p>
exclude (list of ints): 0-based positions of bars (sublists) in `sequence' to which `function' is *not* applied. Only either `section' or `exclude' should be specified, otherwise `exclude' is ignored. 
 </p>
</li>
<li>
<p>
section-args (list or list of lists): Further arguments to `function' added behind the current sublist of `sequence'. If not a nested list, then only a single additional argument is specified for each bar (sublist) to which `function' is applied. 
 </p>
</li>
<li>
<p>
shared-args (list): Further arguments to `function' added behind the current sublist of `sequence' and potentially `section-args'. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<pre>
    (map-section #'(lambda (seq) (pitch-transpose 7 seq)) '((c4 c4 c4) (c4 c4 c4) (c4 c4 c4)) :section '(1 2)) </pre>
<p>
</p>
<pre>
    (map-section #'(lambda (seq) (pitch-transpose 7 seq)) '((c4 c4 c4) (c4 c4 c4) (c4 c4 c4)) :exclude '(0)) </pre>
<p>
</p>
<pre>
    (map-section #'(lambda (seq interval) (pitch-transpose interval seq)) '((c4 c4 c4) (c4 c4 c4) (c4 c4 c4))  
                  :section '(1 2) 
                  :shared-args '(7)) </pre>
<p>
</p>
<pre>
    (map-section #'(lambda (seq interval) (pitch-transpose interval seq)) '((c4 c4 c4) (c4 c4 c4) (c4 c4 c4))  
                  :section '(1 2) 
                  :section-args '(7 12)) </pre>
<p>
</p>
<pre>
    (map-section #'(lambda (seq count divide)  
                      (length-divide count divide seq)) 
                  '((q q q) (q q q) (q q q) (q q q))  
                  :section '(1 2 3) 
                  :section-args '((1 2) (2 3))) </pre>
<p>
</p>
<pre>
    (map-section #'(lambda (seq count divide &amp;rest args)  
                      (apply #'length-divide count divide seq args)) 
                  '((q q q) (q q q) (q q q) (h.))  
                  :section '(1 2 3) 
                  :section-args '((1 2) (2 3)) 
                  :shared-args '(:ignore h.)) </pre>
<p>
</p>
<h4>
See Also: </h4>
<p>
This function is a generalised and somewhat more clean variant of the Opusmodus builtin `do-section'. 
 </p>
<p>
</p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339547">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
edit-omn&nbsp;&nbsp;</td>
<td class="lambda-list">
type notation fun <em>&amp;key</em> (flat nil) (swallow nil) (section nil) (additional-args nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Use function `fun', defined for transforming lists of individual OMN parameters of `type' (e.g., <span class="keyword">
:length, </span>
or <span class="keyword">
:velocity) </span>
to transform omn expression `notation'. This function is intended as a convenient way to generalise your functions to support omn notation as input. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
type: a keyword like <span class="keyword">
:length, </span>
<span class="keyword">
:pitch, </span>
<span class="keyword">
:velocity, </span>
<span class="keyword">
:duration, </span>
or <span class="keyword">
:articulation </span>
(any keyword supported by function omn or make-omn). 
 </p>
</li>
<li>
<p>
notation: a omn sequence or a plain parameter list (can be nested). 
 </p>
</li>
<li>
<p>
fun: a function expecting a parameter sequence of given type. It is sufficient to support only a flat input list, support for nested lists is added implicitly. 
 </p>
</li>
<li>
<p>
flat: whether or not `fun' expects a flat input list. 
 </p>
</li>
<li>
<p>
swallow: if `type' is <span class="keyword">
:length, </span>
and `fun' turns notes into rests, the argument `swallow' sets whether the pitches of these notes should be shifted to the next note or omitted (swallowed). `swallow' is ignored if notation is a plain parameter list (e.g., a 
 </p>
</li>
<li>
<p>
section: only process the sublists (bars) at the positions given to this argument. Arg is ignored if `flat' is T. 
 </p>
</li>
<li>
<p>
additional-args (list of args): `additional-args' allows implementing 'dynamic' arguments, i.e., transformations that change over the sublists of `notation' depending on a list of arguments instead of a plain value. If `additional-args' is nil, then `fun' expects parameter values directly. However, if it is a list, then `fun' expects a list where the parameter values are the first element, and `additional-args' (if `flat' is T) or an element thereof (if `flat' is NIL) the second element in the list expected by `fun'. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<p>
Roll your own transposition function. 
 </p>
<p>
First define an aux def supporting only a flat list of pitches. 
 </p>
<p>
</p>
<pre>
    (defun my-transposition-aux (interval pitches) 
       (midi-to-pitch (loop for p in (pitch-to-midi pitches) 
                            collect (+ p interval)))) </pre>
<p>

 Test that function. 
 </p>
<pre>
    (my-transposition-aux 7 '(c4 e4 g4))  
      =&gt; (g4 b4 d5) </pre>
<p>
Now, based on that aux function, define a function that supports also full OMN sequences. You can later expand this new function further with edit-omn to also support arguments like section and flat (see below). 
 </p>
<pre>
    (defun my-transposition (interval omn) 
       (edit-omn :pitch omn 
                 #'(lambda (ps) (my-transposition-aux interval ps)))) </pre>
<p>
Test the new function with nested OMN including rests. 
 </p>
<pre>
    (my-transposition 7 '((q c4 mp -q q e4 q f4) (h g4 tr2))) 
      =&gt; ((q g4 mp - b4 c5) (h d5 mp tr2)) </pre>
<p>
Another example: expand the built-in function `length-rest-series' to support arbitrary OMN expressions (not just length lists), and additionally the arguments `swallow' and `section'. 
 </p>
<p>
</p>
<pre>
    (defun note-rest-series (positions sequence &amp;key (flat nil) (swallow nil) (section nil)) 
       (edit-omn :length sequence  
                 #'(lambda (ls) (length-rest-series positions ls)) 
                 :swallow swallow 
     	        :section section 
     	        :flat flat)) 
      
     (setf melody '((s eb6 &lt; leg f5 &lt; leg c5 &lt; leg f5 &lt; leg) (e e6 f - -q))) 
     (note-rest-series '(1 1) melody :swallow T :section '(0)) </pre>
<p>
The next example demonstrates how 'dynamic' arguments can be implemented, i.e. arguments that support different values for subsections. Below is a simplified definition of the function rotate-omn. Note how the function argument `n' is handed to the argument `additional-args' of `edit-omn' if `n' is a list. The function given to `edit-omn' also tests whether `n' is a list, and in that case extracts the OMN sublist to rotate as first element of the function argument `xs' and the amount of the rotation of this sublist as second element of `xs'. Further 'dynamic' arguments could be implemented by handing `additional-args' a list of argument lists to use, and by then extracting the relevant elements of such sublists within the function given to `edit-omn'. 
 </p>
<p>
</p>
<pre>
    (defun rotate-omn (n sequence &amp;key (parameter :pitch) (flat T) (section nil)) 
       (let ((n-list-arg? (listp n))) 
         (edit-omn parameter sequence 
     	          #'(lambda (xs) 
     		      (if n-list-arg? 
     		          (gen-rotate (second xs) (first xs)) 
     		          (gen-rotate n xs))) 
     	          :section section 
     	          :flat flat 
     	          :additional-args (when n-list-arg? n)))) </pre>
<p>
The function rotate-omn can now be called with either giving a single number or a list of numbers to its argument `n'. 
 </p>
<p>
</p>
<pre>
    (setf melody '((-h e c4 e4) (q. f4 e g4 q a4) (q g4 f4 e e4 d4))) 
      
     (rotate-omn 1 melody) ; default parameter pitch 
      
     (rotate-omn '(0 1 2) melody :flat nil)  
      
     (rotate-omn '(2 1) melody :section '(1 2) :flat nil :parameter :length) </pre>
<p>

 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339548">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
process-omn2&nbsp;&nbsp;</td>
<td class="lambda-list">
type function sequence <em>&amp;key</em> flatten flat (span :length) swallow section exclude</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Function similar to edit-omn that will soon be built-in in Opusmodus. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339549">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
map-position-in-bar&nbsp;&nbsp;</td>
<td class="lambda-list">
position type sequence fun <em>&amp;key</em> (section nil)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Transforms in the bars of `sequence' the parameter of `type' (e.g., <span class="keyword">
:length) </span>
at `position' with `fun'. 
 </p>
<p>
</p>
<h4>
Examples: </h4>
<p>
Apply the articulation tenuto to every first note in all bars except the last bar. 
 </p>
<pre>
    (map-position-in-bar 0 :articulation  
                          '((-q c4 c4) (q c4 c4 c4) (q c4 c4 c4))  
                          #'(lambda (ignore) 'ten) 
                          :section '(0 1)) </pre>
<p>
</p>
<h4>
Notes: </h4>
<p>
Currently, rests are simply not counted when estimating the position of a parameter other then <span class="keyword">
:length. </span>
Potential workaround: use argument `section'. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339550">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
total-duration&nbsp;&nbsp;</td>
<td class="lambda-list">
sequence <em>&amp;optional</em> float?</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Returns the total duration (length) of `sequence', i.e. the sum of the length of all its notes and rests. 
 </p>
<p>
If `float?' is true the result is a float. 
 </p>
<p>
</p>
<h4>
Examples: </h4>
<pre>
    (total-duration '((h c4 q) (q h tie) (h.))) 
     =&gt; 9/4 </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339551">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
flattened-length-adjust&nbsp;&nbsp;</td>
<td class="lambda-list">
duration sequence</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Currently, the built-in function length-adjust has no <span class="keyword">
:flatten </span>
argument. This function offers a workaround. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339552">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
count-notes&nbsp;&nbsp;</td>
<td class="lambda-list">
notes</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Returns number of notes (ignoring rests) in length list or other OMN expression. 
 </p>
<p>
</p>
<h4>
Examples: </h4>
<p>
</p>
<pre>
    (count-notes '((q c4 c4 c4) (q g4 g4 g4))) </pre>
<p>
* BUG: 
 </p>
<p>
Counts tied notes as multiple notes. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339553">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
phrase-lengths&nbsp;&nbsp;</td>
<td class="lambda-list">
lengths</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Returns the number of notes between rests in the given lengths. 
 
 </p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
length: lengths or OMN (list or list of list). 
 </p>
</li>
</ul>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339554">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
length-subtract&nbsp;&nbsp;</td>
<td class="lambda-list">
<em>&amp;rest</em> length-values</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Subtraction for OMN length values. 
 </p>
<p>
</p>
<h4>
Examples: </h4>
<pre>
    (length-subtract 'w 'q) 
     =&gt; h. </pre>
<p>

 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339555">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
length-add&nbsp;&nbsp;</td>
<td class="lambda-list">
<em>&amp;rest</em> length-values</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Addition of OMN length values. 
 </p>
<p>
</p>
<h4>
Examples: </h4>
<pre>
    (length-add 'w 'q) 
     =&gt; wq </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339556">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
rnd-section&nbsp;&nbsp;</td>
<td class="lambda-list">
section-range probability <em>&amp;key</em> seed</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
The function returns a list of random section numbers intended for the argument section of many Opusmodus functions. The list of returned sections is unsorted. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
section-range (pair of ints): the range of 0-based section positions (including boundaries) within which sections are returned. 
 </p>
</li>
<li>
<p>
probability (float in interval 0-1): the likelyhood by which sections are return, where 0 means the result is nil, 1 means that the result contains all sections within the given range, and, e.g., 0.5 means a 50 percent probability that any section is selected. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<pre>
    (rnd-section '(0 9) 0.5 :seed 1) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339557">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
mk-seed&nbsp;&nbsp;</td>
<td class="lambda-list">
<em>&amp;optional</em> seed</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Generates a random seed value, prints and returns it. Useful for exploring different results of random processes, but then keeping a found solution. 
 </p>
<p>
This function is now rather redundant, as Opusmodus automatically prints seed values of all function calls. 
 </p>
<p>
</p>
<h4>
Arguments: </h4>
<ul>
<li>
<p>
seed (int): optionally fixes generated seed. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<p>
</p>
<pre>
    (rnd-sample 3 '(c4 d4 e4) :seed (mk-seed)) 
     ; 405621 rnd-sample 
     =&gt; (c4 e4 d4)  </pre>
<p>
</p>
<pre>
    (rnd-sample 3 '(c4 d4 e4) :seed (mk-seed 13)) 
     ; 13 rnd-sample 
     =&gt; (e4 d4 e4)  </pre>
<p>

 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g339558">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
ensure-double-list&nbsp;&nbsp;</td>
<td class="lambda-list">
x</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Ensures that `x' is a duble-wrapped list. If not, a list (or two) are wrapped around it. 
 
 As a precaution, if `x' is inconsistently nested, then the result is a flattened version of it with a double list wrapped around. 
 </p>
</div>
</div>
</div>
<div class="cludg-footer">
Generated by&nbsp;<a href="mailto:ihatchondo@common-lisp.net" lang="en">
CLDOC</a>
- 2021-03-30 20:31:35</div>
</body>
</html>
